
--- README.md ---
# Ctrl+C



## Installation

```bash
pip install ctrlc
```

## Basic Usage
```bash
ctrlc run
```

## Flags & Options

- `--ignore-files [none|all]`

    - none: donâ€™t respect any .gitignore/.contextignore.

    - all: always respect both if present.

- `--threshold <bytes>`

    Skip files larger than this size (in bytes).

- `--compress [none|gzip|zip]`

    Output compression. Default none.

## Configuration

Create optional `pyproject.toml` section `[tool.ctrlc]` or `.contextignore` in root.

```
[tool.ctrlc]
ignore_files = "all"
threshold = 1048576
template = "default"
```

## Example Usage
```bash
ctrlc run --compress gzip --threshold 1000000
```
--- ctrlc\cli.py ---
import click, os
from .core import collect_files, write_bundle
from .config import load_config

from rich.console import Console
from rich.panel import Panel
from rich.text import Text
from rich.table import Table

console = Console()

class RichHelpGroup(click.Group):
    def format_help(self, ctx, formatter):
        # rich replaces the entire help output
        self.rich_help()

    def invoke(self, ctx):
        if "--help" in ctx.args or "-h" in ctx.args:
            self.rich_help()
            ctx.exit()
        super().invoke(ctx)

    def rich_help(self):
        console.print(Panel.fit(
            Text.from_markup("[bold]Bundle your codebase context[/] for AI tools, debugging, and sharing.", justify="center"),
            title="[bold green]ðŸ“¦ Ctrl+C",
            border_style="green"
        ))

        table = Table.grid(padding=(0, 2))
        table.add_column("Option", style="cyan bold")
        table.add_column("Description", style="white")

        table.add_row("--ignore-files \\[none|all|git|context]",
                      "Ignore files using .gitignore/.contextignore. Default: all.")
        table.add_row("--threshold <bytes>",
                      "Skip files larger than this size (in bytes).")
        table.add_row("--compress \\[none|gzip|zip|tar.gz]",
                      "Compress the output. Default: none.")
        table.add_row("--output <filename>",
                      "Name of output file (e.g. context.txt)")

        console.print(table)
        console.print("\n[bold yellow]Example:[/] [green]ctrlc run --compress gzip --threshold 1000000\n[/]")

@click.group(cls=RichHelpGroup)
def main():
    """Ctrl+C: bundle project context"""
    pass

@main.command()
@click.option(
    '--ignore-files',
    type=click.Choice(['none', 'all', 'git', 'context']),
    default=None,
    show_choices=False,
    help='Ignore patterns: none, git, context, or all'
)
@click.option(
    '--threshold',
    type=int,
    default=None,
    help='Skip files larger than this size in bytes'
)
@click.option(
    '--compress',
    type=click.Choice(['none', 'gzip', 'zip', 'tar.gz'], case_sensitive=False),
    default='none',
    show_choices=False,
    help='Compression method: none, gzip, zip, or tar.gz'
)
@click.option(
    '--output',
    default='context.txt',
    help='Base output filename'
)
def run(ignore_files, threshold, compress, output):
    root = os.getcwd()
    cfg = load_config(root)
    mode = ignore_files or cfg.get('ignore_files', 'all')
    thr = threshold or cfg.get('threshold')

    # files, git_ignored, ctx_ignored, size_skipped, builtin_ignored = collect_files(root, mode, threshold)
    files, git_ignored, ctx_ignored, size_skipped, builtin_ignored, git_exists, ctx_exists = collect_files(root, mode, threshold)
    write_bundle(root, output, files, compress)
    # Reporting
    console.print(Panel.fit(f"Wrote {len(files)} files to {output}", title="Ctrl+C", style="green"))

    # TO BE CHANGED TO RICH PRINTS
    # if builtin_ignored:
    #     click.echo(f"{builtin_ignored} files skipped due to built-in ignore rules (e.g., .git, node_modules, etc.)")

    # # Gitignore reporting
    # if mode in ('all', 'git'):
    #     if git_exists:
    #         if git_ignored:
    #             click.echo(f".gitignore file found and used to ignore {git_ignored} files")
    #         else:
    #             click.echo(".gitignore file found but did not match any files")
    #     else:
    #         click.echo(".gitignore mode active, but no .gitignore file found")

    # # Contextignore reporting
    # if mode in ('all', 'context'):
    #     if ctx_exists:
    #         if ctx_ignored:
    #             click.echo(f".contextignore file found and used to ignore {ctx_ignored} files")
    #         else:
    #             click.echo(".contextignore file found but did not match any files")
    #     else:
    #         click.echo(".contextignore mode active, but no .contextignore file found")

    # Size threshold
    if threshold:
        click.echo(f"{size_skipped} files skipped due to size threshold ({threshold} bytes)")

if __name__ == '__main__':
    main()
--- ctrlc\config.py ---
import toml, os

def load_config(root: str):
    cfg = {}
    # load pyproject.toml
    path = os.path.join(root, 'pyproject.toml')
    if os.path.exists(path):
        data = toml.load(path)
        cfg = data.get('tool', {}).get('ctrlc', {})
    return cfg
--- ctrlc\core.py ---
import os, gzip, zipfile, tarfile
from .ignore import load_ignore

BUILTIN_IGNORES = {
    '.git', '.svn', '.hg', '__pycache__', '.DS_Store', 'context.txt',
    'node_modules', '.vscode', '.idea', '.env', '.venv', '.contextignore', '.gitignore'
}

def collect_files(root, ignore_mode, threshold):
    git_path = os.path.join(root, '.gitignore')
    ctx_path = os.path.join(root, '.contextignore')
    git_exists = os.path.exists(git_path)
    ctx_exists = os.path.exists(ctx_path)

    git = load_ignore(root, '.gitignore') if ignore_mode in ('all', 'git') and git_exists else None
    ctx = load_ignore(root, '.contextignore') if ignore_mode in ('all', 'context') and ctx_exists else None

    included = []
    git_ignored = 0
    ctx_ignored = 0
    size_skipped = 0
    builtin_ignored = 0

    for dirpath, dirnames, filenames in os.walk(root):
        dirnames[:] = [d for d in dirnames if d not in BUILTIN_IGNORES]

        for name in filenames:
            full = os.path.join(dirpath, name)
            rel = os.path.relpath(full, root)

            if any(part in BUILTIN_IGNORES for part in rel.split(os.sep)):
                builtin_ignored += 1
                continue

            if git and git.match_file(rel):
                git_ignored += 1
                continue
            if ctx and ctx.match_file(rel):
                ctx_ignored += 1
                continue

            if threshold and os.path.getsize(full) > threshold:
                size_skipped += 1
                continue

            included.append((full, rel))

    return included, git_ignored, ctx_ignored, size_skipped, builtin_ignored, git_exists, ctx_exists

def write_bundle(root, out_name, files, compress):
    if compress == 'gzip':
        with gzip.open(out_name + '.gz', 'wb') as out:
            for full, rel in files:
                header = f'\n--- {rel} ---\n'.encode('utf-8')
                out.write(header)
                with open(full, 'rb') as infile:
                    while True:
                        chunk = infile.read(8192)
                        if not chunk:
                            break
                        out.write(chunk)

    elif compress == 'zip':
        with zipfile.ZipFile(out_name + '.zip', 'w') as z:
            for full, rel in files:
                z.write(full, rel)

    elif compress == 'tar.gz':
        with tarfile.open(out_name + '.tar.gz', 'w:gz') as tar:
            for full, rel in files:
                tar.add(full, arcname=rel)

    else:
        with open(out_name, 'w', encoding='utf-8') as out:
            for full, rel in files:
                out.write(f'\n--- {rel} ---\n')
                try:
                    with open(full, 'r', encoding='utf-8') as infile:
                        out.write(infile.read())
                except UnicodeDecodeError:
                    out.write("[[Skipped: Binary or non-UTF8 content]]\n")


# def write_bundle(root, out_name, files, compress):
#     if compress == 'gzip':
#         with gzip.open(out_name + '.gz', 'wb') as out:
#             for full, rel in files:
#                 header = f'\n--- {rel} ---\n'.encode('utf-8')
#                 out.write(header)
#                 with open(full, 'rb') as infile:
#                     while True:
#                         chunk = infile.read(8192)
#                         if not chunk:
#                             break
#                         out.write(chunk)

#     elif compress == 'zip':
#         with zipfile.ZipFile(out_name + '.zip', 'w') as z:
#             for full, rel in files:
#                 z.write(full, rel)

#     elif compress == 'tar.gz':
#         with tarfile.open(out_name + '.tar.gz', 'w:gz') as tar:
#             for full, rel in files:
#                 tar.add(full, arcname=rel)
#     else:
#         with open(out_name, 'w') as out:
#             for full, rel in files:
#                 out.write(f'\n--- {rel} ---\n')
#                 out.write(open(full).read())
--- ctrlc\ignore.py ---
import os
from pathspec import PathSpec
from pathspec.patterns.gitwildmatch import GitWildMatchPattern

def load_ignore(root: str, filename: str):
    path = os.path.join(root, filename)
    if not os.path.exists(path):
        return None
    with open(path, 'r') as f:
        patterns = [l.strip() for l in f if l.strip() and not l.startswith('#')]
    return PathSpec.from_lines(GitWildMatchPattern, patterns)
--- ctrlc\__init__.py ---
